name: Release on main

on:
  push:
    branches: [ main ]
    # Evita retrigger quando committiamo il file delle note su main
    paths-ignore:
      - 'ReleaseNotes/**'
  workflow_dispatch:
    inputs:
      release_channel:
        description: 'Select release channel'
        type: choice
        options: [ alpha, beta, rc, stable ]
        default: alpha

permissions:
  contents: write
  issues: write
  pull-requests: write

concurrency:
  group: release-main
  cancel-in-progress: false

jobs:
  release:
    name: Create Release (branch, tag, draft, artifacts)
    runs-on: ubuntu-latest

    env:
      DOTNET_VERSION: '8.0.x'
      NODE_VERSION: '20'
      SOLUTION: Momentum.sln
      WEB_DIR: src/web-core
      APPHOST_DIR: src/AppHost
      ARTIFACTS_DIR: artifacts
      REPORT_DIR: reports
      # Manuale: input. Automatico: vars.RELEASE_CHANNEL. Default: alpha.
      RELEASE_CHANNEL: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.release_channel) || vars.RELEASE_CHANNEL || 'alpha' }}

    steps:
      - name: Checkout (full history, main)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main

      # ---- AUTO MODE GUARD: esegui solo se questo push su main √® legato a una PR (merge/squash/rebase) ----
      - name: Detect if this push comes from a merged PR
        id: prdetect
        if: github.event_name == 'push'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          # Lista PR associate al commit (funziona anche per squash merge)
          count=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "Accept: application/vnd.github.groot-preview+json" \
            "/repos/${GITHUB_REPOSITORY}/commits/${GITHUB_SHA}/pulls" \
            --jq 'length' || echo "0")
          echo "prs_count=$count" >> "$GITHUB_OUTPUT"
          echo "PRs linked to commit: $count"

      - name: Skip release (push not coming from PR merge)
        if: github.event_name == 'push' && steps.prdetect.outputs.prs_count == '0'
        run: |
          echo "This push is not associated with any PR. Skipping release."
          exit 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Restore .NET
        run: dotnet restore ${{ env.SOLUTION }}

      # ---- 1) Calcola la NEXT_BASE da ultimo STABLE (vX.Y.Z) + conventional commits ----
      - name: Calculate next base version (SemVer from Conventional Commits)
        id: semver
        shell: bash
        run: |
          set -euo pipefail

          LAST_STABLE="$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=-version:refname | head -n1 || true)"
          [[ -z "${LAST_STABLE}" ]] && LAST_STABLE="v0.1.0"

          BASE="${LAST_STABLE#v}"  # X.Y.Z

          COMMITS="$(git log --pretty=format:%s "${LAST_STABLE}..HEAD" || true)"

          BUMP="none"
          if [[ -n "${COMMITS}" ]]; then
            BUMP="patch"
            if echo "${COMMITS}" | grep -Eqi 'BREAKING CHANGE|!:' ; then
              BUMP="major"
            elif echo "${COMMITS}" | grep -Eqi '^feat(\(|:)|^feat!'; then
              BUMP="minor"
            elif echo "${COMMITS}" | grep -Eqi '^fix(\(|:)|^perf(\(|:)|^refactor(\(|:)|^fix!|^perf!|^refactor!' ; then
              BUMP="patch"
            fi
          fi

          IFS='.' read -r MA MI PA <<< "${BASE}"
          case "${BUMP}" in
            major) MA=$((MA+1)); MI=0; PA=0;;
            minor) MI=$((MI+1)); PA=0;;
            patch) PA=$((PA+1));;
            none)  : ;;
          esac

          NEXT_BASE="${MA}.${MI}.${PA}"

          echo "last_stable=${LAST_STABLE}" >> "$GITHUB_OUTPUT"
          echo "next_base=${NEXT_BASE}"     >> "$GITHUB_OUTPUT"
          echo "bump=${BUMP}"               >> "$GITHUB_OUTPUT"

      # ---- 2) Determina BASE_VERSION del "ciclo" + tag_name coerente (alpha.0, alpha.1...) ----
      - name: Determine release channel metadata (cycle-based)
        id: release_meta
        shell: bash
        env:
          INPUT_CHANNEL: ${{ env.RELEASE_CHANNEL }}
          NEXT_BASE: ${{ steps.semver.outputs.next_base }}
          LAST_STABLE: ${{ steps.semver.outputs.last_stable }}
        run: |
          set -euo pipefail

          CHANNEL="${INPUT_CHANNEL:-alpha}"
          case "${CHANNEL}" in alpha|beta|rc|stable) ;; *) echo "Unsupported RELEASE_CHANNEL '${CHANNEL}'" >&2; exit 1;; esac

          LAST_STABLE_BASE="${LAST_STABLE#v}"

          # Trova l'ultima prerelease tra alpha/beta/rc (ordinata per versione)
          LATEST_PRE="$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*-*' --sort=-version:refname \
            | grep -E '\-(alpha|beta|rc)\.[0-9]+$' | head -n1 || true)"

          CYCLE_BASE=""
          if [[ -n "${LATEST_PRE}" ]]; then
            PRE_BASE="${LATEST_PRE#v}"
            PRE_BASE="${PRE_BASE%%-*}"   # X.Y.Z
            # Se non esiste ancora lo stable di quella base, il ciclo √® "aperto": continua su PRE_BASE
            if [[ "${PRE_BASE}" != "${LAST_STABLE_BASE}" ]] && ! git rev-parse -q --verify "refs/tags/v${PRE_BASE}" >/dev/null; then
              CYCLE_BASE="${PRE_BASE}"
            fi
          fi

          BASE_VERSION="${CYCLE_BASE:-${NEXT_BASE}}"
          [[ -z "${BASE_VERSION}" ]] && { echo "Missing base version" >&2; exit 1; }

          # Calcola prev_tag per compare
          prev_stable() {
            git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=-version:refname | head -n1 || true
          }

          # Pre-numero: vBASE-channel.N (parte da 0 per nuova base)
          PRE_NUM=""
          if [[ "${CHANNEL}" == "stable" ]]; then
            TAG_NAME="v${BASE_VERSION}"
            IS_PRERELEASE="false"
            IS_LATEST="true"
            RELEASE_NAME="üöÄ v${BASE_VERSION}"
            PREV_TAG="$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=-version:refname | grep -v "^v${BASE_VERSION}$" | head -n1 || true)"
          else
            max=-1
            while read -r t; do
              n="${t##*.}"
              [[ "${n}" =~ ^[0-9]+$ ]] || continue
              (( n > max )) && max=$n
            done < <(git tag --list "v${BASE_VERSION}-${CHANNEL}.*" --sort=version:refname || true)

            PRE_NUM=$((max+1))
            TAG_NAME="v${BASE_VERSION}-${CHANNEL}.${PRE_NUM}"
            IS_PRERELEASE="true"
            IS_LATEST="false"
            RELEASE_NAME="üöÄ v${BASE_VERSION}-${CHANNEL}.${PRE_NUM}"

            if [[ "${PRE_NUM}" -gt 0 ]]; then
              PREV_TAG="v${BASE_VERSION}-${CHANNEL}.$((PRE_NUM-1))"
            else
              PREV_TAG="$(prev_stable)"
            fi
          fi

          [[ -z "${PREV_TAG}" ]] && PREV_TAG="${LAST_STABLE:-v0.1.0}"

          # Base tag used to generate cumulative release notes
          if [[ "${CHANNEL}" == "stable" ]]; then
            NOTES_BASE_TAG="${PREV_TAG}"
          else
            NOTES_BASE_TAG="${LAST_STABLE:-v0.1.0}"
          fi


          REPO="${GITHUB_REPOSITORY}"
          OWNER="${REPO%%/*}"
          NAME="${REPO#*/}"
          COMPARE_URL="https://github.com/${OWNER}/${NAME}/compare/${NOTES_BASE_TAG}...${TAG_NAME}"

          echo "release_channel=${CHANNEL}"   >> "$GITHUB_OUTPUT"
          echo "version_base=${BASE_VERSION}" >> "$GITHUB_OUTPUT"
          echo "tag_name=${TAG_NAME}"         >> "$GITHUB_OUTPUT"
          echo "release_name=${RELEASE_NAME}" >> "$GITHUB_OUTPUT"
          echo "is_prerelease=${IS_PRERELEASE}" >> "$GITHUB_OUTPUT"
          echo "is_latest=${IS_LATEST}"       >> "$GITHUB_OUTPUT"
          echo "prev_tag=${PREV_TAG}"         >> "$GITHUB_OUTPUT"
          echo "notes_base_tag=${NOTES_BASE_TAG}" >> "$GITHUB_OUTPUT"
          echo "compare_url=${COMPARE_URL}"   >> "$GITHUB_OUTPUT"
          echo "pre_num=${PRE_NUM}"           >> "$GITHUB_OUTPUT"

      # ---- 3) Branch release sempre coerente (mai vuoto) ----
      - name: Create / update release branch
        env:
          REL: release/v${{ steps.release_meta.outputs.version_base }}
        run: |
          set -euo pipefail
          if [[ -z "${REL}" ]]; then
            echo "REL is empty" >&2
            exit 1
          fi

          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git fetch origin --prune

          if git show-ref --verify --quiet "refs/remotes/origin/${REL}"; then
            git switch -C "${REL}" "origin/${REL}"
          else
            git switch -c "${REL}"
          fi

          git reset --hard origin/main
          git push --force-with-lease origin "${REL}"

      - name: Bump version in solution (best-effort)
        env:
          VERSION: ${{ steps.release_meta.outputs.version_base }}
          REL: release/v${{ steps.release_meta.outputs.version_base }}
        run: |
          set -euo pipefail
          git switch "${REL}"

          if [[ -f Directory.Build.props ]]; then
            sed -i -E "s|<Version>[^<]+</Version>|<Version>${VERSION}</Version>|" Directory.Build.props || true
          fi

          if [[ -f "${WEB_DIR}/package.json" ]]; then
            jq --arg v "${VERSION}" '.version=$v' "${WEB_DIR}/package.json" > "${WEB_DIR}/package.json.tmp" && mv "${WEB_DIR}/package.json.tmp" "${WEB_DIR}/package.json"
          fi

          if ! git diff --quiet; then
            git add -A
            git commit -m "chore(release): bump version to v${VERSION}"
            git push origin "${REL}"
          fi

      - name: Build artifacts
        run: |
          set -euo pipefail
          mkdir -p "${ARTIFACTS_DIR}"

          dotnet restore "${SOLUTION}"
          dotnet build "${SOLUTION}" -c Release --no-restore

          if [[ -d "${APPHOST_DIR}" ]]; then
            OUT="${ARTIFACTS_DIR}/apphost-publish"
            dotnet publish "${APPHOST_DIR}" -c Release -o "${OUT}"
            if [[ -d "${OUT}" ]] && compgen -G "${OUT}/*" > /dev/null; then
              (cd "${ARTIFACTS_DIR}" && zip -rq apphost-publish.zip apphost-publish)
            fi
          fi

          if [[ -f "${WEB_DIR}/package.json" ]]; then
            npm ci --prefix "${WEB_DIR}"
            npm run build --prefix "${WEB_DIR}"
            DIST_ROOT="${WEB_DIR}/dist"
            if [[ -d "${DIST_ROOT}" ]]; then
              CANDIDATE=$(find "${DIST_ROOT}" -type d -name browser -print -quit || true)
              [[ -n "${CANDIDATE}" ]] && DIST_TO_ZIP="${CANDIDATE}" || DIST_TO_ZIP="${DIST_ROOT}"
              OUT_ZIP="${GITHUB_WORKSPACE}/${ARTIFACTS_DIR}/web-core-dist.zip"
              mkdir -p "$(dirname "${OUT_ZIP}")"
              (cd "${DIST_TO_ZIP}" && zip -rq "${OUT_ZIP}" .) || true
            fi
          fi

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install notes deps
        run: |
          set -euo pipefail
          python -m pip install -U pip
          if [ -f tools/release_notes/requirements.txt ]; then
            pip install -r tools/release_notes/requirements.txt
          fi
          python - <<'PY'
          import sys, subprocess
          subprocess.check_call([sys.executable, "-m", "pip", "install", "requests"])
          PY

      - name: Generate final release notes (Markdown)
        id: relnotes
        env:
          ENABLE_LLM: "true"
          LLM_PROVIDER: "openai"
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          LLM_MODEL: "gpt-4o-mini"
          LLM_TEMPERATURE: "0.2"
          PROJECT_NAME: Momentum
          RELEASE_NAME: ${{ steps.release_meta.outputs.release_name }}
          RELEASE_CHANNEL: ${{ steps.release_meta.outputs.release_channel }}
          IS_PRERELEASE: ${{ steps.release_meta.outputs.is_prerelease }}
          TAG_NAME: ${{ steps.release_meta.outputs.tag_name }}
          PREV_TAG: ${{ steps.release_meta.outputs.prev_tag }}
          NOTES_BASE_TAG: ${{ steps.release_meta.outputs.notes_base_tag }}
          COMPARE_URL: ${{ steps.release_meta.outputs.compare_url }}
          ARTIFACTS_DIR: ${{ env.ARTIFACTS_DIR }}
        run: |
          set -euo pipefail

          git fetch origin --prune --tags
          mkdir -p "${ARTIFACTS_DIR}" ReleaseNotes

          OUT_ART="${ARTIFACTS_DIR}/RELEASE_NOTES.md"
          OUT_REPO="ReleaseNotes/${TAG_NAME}.md"
          RAW_NOTES="${ARTIFACTS_DIR}/CHANGELOG_RAW.md"

          # rendile disponibili al Python in questo step
          export OUT_ART OUT_REPO RAW_NOTES

          # se ti serve anche per step successivi
          echo "OUT_ART=${OUT_ART}"   >> "$GITHUB_ENV"
          echo "OUT_REPO=${OUT_REPO}" >> "$GITHUB_ENV"
          echo "RAW_NOTES=${RAW_NOTES}" >> "$GITHUB_ENV"

          python tools/release_notes/generate_release_notes.py \
            --base "${NOTES_BASE_TAG}" \
            --head "origin/main" \
            --version "${TAG_NAME}" \
            --out "${RAW_NOTES}"

          python - <<'PY'
          import os, re, subprocess
          from pathlib import Path

          raw_notes_path = Path(os.environ.get("RAW_NOTES", "artifacts/CHANGELOG_RAW.md"))
          out_art = Path(os.environ.get("OUT_ART", "artifacts/RELEASE_NOTES.md"))
          out_repo = Path(os.environ.get("OUT_REPO", "ReleaseNotes/RELEASE_NOTES.md"))

          project_name = os.environ.get("PROJECT_NAME", "Momentum")
          release_name = os.environ.get("RELEASE_NAME", "")
          channel = os.environ.get("RELEASE_CHANNEL", "")
          tag_name = os.environ.get("TAG_NAME", "")
          notes_base_tag = os.environ.get("NOTES_BASE_TAG", "")
          compare_url = os.environ.get("COMPARE_URL", "")
          is_prerelease = os.environ.get("IS_PRERELEASE", "false")

          commit_range = f"{notes_base_tag}..origin/main" if notes_base_tag else "origin/main"
          fmt = "%H%x1f%an%x1f%ad%x1f%s%x1f%b%x1e"
          try:
              log_out = subprocess.check_output(
                  ["git", "log", commit_range, f"--pretty=format:{fmt}", "--date=short"],
                  text=True
              )
          except subprocess.CalledProcessError:
              log_out = ""

          entries = []
          if log_out:
              for rec in log_out.split("\x1e"):
                  rec = rec.strip()
                  if not rec:
                      continue
                  parts = rec.split("\x1f")
                  if len(parts) < 5:
                      continue
                  sha, author, date, subject, body = parts[:5]
                  entries.append({
                      "sha": sha, "author": author, "date": date,
                      "subject": subject.strip(), "body": (body or "").strip()
                  })

          conv_re = re.compile(r"^(?P<type>[a-zA-Z]+)(?:\((?P<scope>[^)]+)\))?(?P<bang>!)?:\s*(?P<msg>.+)$")

          def classify(commit):
              m = conv_re.match(commit["subject"])
              ctype = m.group("type").lower() if m else "other"
              scope = m.group("scope") if m else None
              msg = m.group("msg") if m else commit["subject"]
              breaking = bool(m and m.group("bang")) or ("BREAKING CHANGE" in commit["body"])
              return ctype, scope, msg.strip(), breaking

          def format_line(commit, scope, msg):
              prefix = f"**{scope}**: " if scope else ""
              return f"- {prefix}{msg} ({commit['sha'][:7]}) by {commit['author']}"

          highlights, changes, fixes, breaking = [], [], [], []

          for commit in entries:
              ctype, scope, msg, breaking_flag = classify(commit)
              line = format_line(commit, scope, msg)
              if ctype == "feat":
                  if len(highlights) < 5:
                      highlights.append(line)
                  changes.append(line)
              elif ctype == "fix":
                  fixes.append(line)
              else:
                  changes.append(line)
              if breaking_flag:
                  breaking.append(line)

          def ensure_content(lines):
              return lines if lines else ["- _No entries recorded._"]

          header = [
              f"# {project_name} ‚Äî {release_name}",
              f"Channel: {channel}",
              f"Prerelease: {is_prerelease}",
              f"Commit range: {prev_tag}..{tag_name}" if prev_tag and tag_name else "",
              "",
          ]

          section_map = [
              ("Highlights", ensure_content(highlights)),
              ("Changes", ensure_content(changes)),
              ("Fixes", ensure_content(fixes)),
              ("Breaking changes", ensure_content(breaking)),
          ]

          body_lines = []
          for title, lines in section_map:
              body_lines.append(f"## {title}")
              body_lines.extend(lines)
              body_lines.append("")

          if compare_url:
              body_lines.append("## Changelog diff")
              body_lines.append(compare_url)
              body_lines.append("")

          raw_appendix = []
          if raw_notes_path.exists():
              raw_text = raw_notes_path.read_text(encoding="utf-8").strip()
              if raw_text:
                  raw_appendix += ["---", "## Detailed changelog", "", raw_text]

          final_text = "\n".join([x for x in header if x is not None] + body_lines + raw_appendix).rstrip() + "\n"
          out_art.write_text(final_text, encoding="utf-8")
          out_repo.write_text(final_text, encoding="utf-8")
          PY

          echo "artifacts_file=${OUT_ART}" >> "$GITHUB_OUTPUT"
          echo "repo_file=${OUT_REPO}" >> "$GITHUB_OUTPUT"

      - name: Commit release notes on main
        env:
          FILE: ${{ steps.relnotes.outputs.repo_file }}
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git fetch origin --prune
          git switch main
          git pull --ff-only origin main || true

          git add "${FILE}"
          if ! git diff --cached --quiet; then
            git commit -m "docs(release): add ${FILE} [skip ci]"
            git push origin main
          else
            echo "Release notes gi√† presenti su main, nessun commit."
          fi

      - name: Create tag on main
        env:
          TAG: ${{ steps.release_meta.outputs.tag_name }}
        run: |
          set -euo pipefail
          git fetch origin --prune
          MAIN_SHA="$(git rev-parse origin/main)"
          git tag -a "${TAG}" "${MAIN_SHA}" -m "Release ${TAG}" || true
          git push origin "${TAG}" || true

      - name: Create GitHub Release (draft) on main
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release_meta.outputs.tag_name }}
          target_commitish: main
          draft: true
          prerelease: ${{ steps.release_meta.outputs.is_prerelease }}
          make_latest: ${{ steps.release_meta.outputs.is_latest }}
          name: ${{ steps.release_meta.outputs.release_name }}
          generate_release_notes: false
          body_path: ${{ steps.relnotes.outputs.artifacts_file }}
          files: |
            artifacts/*.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Append asset links to release notes
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const { owner, repo } = context.repo;
            const tag = ${{ toJSON(steps.release_meta.outputs.tag_name) }};
            let rel = null;
            for (let i = 0; i < 10; i++) {
              try {
                rel = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
                break;
              } catch (e) {
                if (e.status === 404) { await new Promise(r => setTimeout(r, 3000)); continue; }
                throw e;
              }
            }
            if (!rel) { core.warning(`Release ${tag} non ancora visibile: skip.`); return; }
            const assets = await github.rest.repos.listReleaseAssets({ owner, repo, release_id: rel.data.id, per_page: 100 });
            const lines = (assets.data || []).map(a => `- [${a.name}](${a.browser_download_url})`);
            if (!lines.length) return;
            const section = `\n\n### Download\n${lines.join('\n')}\n`;
            await github.rest.repos.updateRelease({ owner, repo, release_id: rel.data.id, body: (rel.data.body || '') + section });

      - name: Upload CI artifacts (for debugging)
        uses: actions/upload-artifact@v4
        with:
          name: release-artifacts-${{ steps.release_meta.outputs.version_base }}
          path: artifacts
          if-no-files-found: ignore
