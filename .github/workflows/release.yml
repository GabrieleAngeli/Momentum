name: Release on main

on:
  push:
    branches: [ main ]

permissions:
  contents: write
  issues: write
  pull-requests: write

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  release:
    name: Create Release (branch, tag, draft, artifacts)
    runs-on: ubuntu-latest

    env:
      DOTNET_VERSION: '8.0.x'
      NODE_VERSION: 20
      SOLUTION: Momentum.sln
      WEB_DIR: src/web-core
      APPHOST_DIR: src/AppHost
      ARTIFACTS_DIR: artifacts  

    steps:
      - name: Checkout (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with: 
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with: 
          node-version: ${{ env.NODE_VERSION }}

      - name: Restore .NET
        run: dotnet restore ${{ env.SOLUTION }}

      - name: Calculate next version (SemVer from Conventional Commits)
        id: semver
        shell: bash
        run: |
          set -euo pipefail
          LAST_TAG="$(git describe --tags --abbrev=0 2>/dev/null || true)"
          if [[ -z "${LAST_TAG}" ]]; then LAST_TAG="v0.1.0"; fi
          BASE="${LAST_TAG#v}"
          COMMITS="$(git log --pretty=format:%s "${LAST_TAG}..HEAD" || true)"
          BUMP="patch"
          if echo "${COMMITS}" | grep -Eqi 'BREAKING CHANGE|!:' ; then
            BUMP="major"
          elif echo "${COMMITS}" | grep -Eqi '^feat(\(|:)|^feat!'; then
            BUMP="minor"
          elif echo "${COMMITS}" | grep -Eqi '^fix(\(|:)|^perf(\(|:)|^refactor(\(|:)|^fix!|^perf!|^refactor!' ; then
            BUMP="patch"
          else
            if [[ -n "${COMMITS}" ]]; then BUMP="patch"; fi
          fi
          IFS='.' read -r MA MI PA <<< "${BASE}"
          case "${BUMP}" in
            major) MA=$((MA+1)); MI=0; PA=0;;
            minor) MI=$((MI+1)); PA=0;;
            patch) PA=$((PA+1));;
          esac
          NEW_VERSION="${MA}.${MI}.${PA}"
          echo "new_version=${NEW_VERSION}"            >> "$GITHUB_OUTPUT"
          echo "release_branch=release/v${NEW_VERSION}" >> "$GITHUB_OUTPUT"
          echo "tag=v${NEW_VERSION}"                   >> "$GITHUB_OUTPUT"
          echo "last_tag=${LAST_TAG}"                  >> "$GITHUB_OUTPUT"

      - name: Create / update release branch
        env: 
          REL: ${{ steps.semver.outputs.release_branch }}
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git fetch origin --prune
          if git rev-parse --verify "$REL" >/dev/null 2>&1; then
            git switch "$REL"
            git reset --hard origin/main
          else
            git switch -c "$REL"
            git reset --hard origin/main
          fi
          git push --force-with-lease origin "$REL"

      - name: Bump version in solution (best-effort)
        env: 
          VERSION: ${{ steps.semver.outputs.new_version }}
        run: |
          set -euo pipefail
          if [[ -f Directory.Build.props ]]; then
            sed -i -E "s|<Version>[^<]+</Version>|<Version>${VERSION}</Version>|" Directory.Build.props || true
          fi
          if [[ -f "${WEB_DIR}/package.json" ]]; then
            jq --arg v "${VERSION}" '.version=$v' "${WEB_DIR}/package.json" > "${WEB_DIR}/package.json.tmp" && mv "${WEB_DIR}/package.json.tmp" "${WEB_DIR}/package.json"
          fi
          if ! git diff --quiet; then
            git add -A
            git commit -m "chore(release): bump version to v${VERSION}"
            git push origin "${{ steps.semver.outputs.release_branch }}"
          fi

      - name: Build artifacts
        run: |
          set -euo pipefail
          mkdir -p "${ARTIFACTS_DIR}"
          dotnet restore "${SOLUTION}"
          dotnet build "${SOLUTION}" -c Release --no-restore
          if [[ -d "${APPHOST_DIR}" ]]; then
            OUT="${ARTIFACTS_DIR}/apphost-publish"
            dotnet publish "${APPHOST_DIR}" -c Release -o "${OUT}"
            if [[ -d "${OUT}" ]] && compgen -G "${OUT}/*" > /dev/null; then
              (cd "${ARTIFACTS_DIR}" && zip -rq apphost-publish.zip apphost-publish)
            fi
          fi
          if [[ -f "${WEB_DIR}/package.json" ]]; then
            npm ci --prefix "${WEB_DIR}"
            npm run build --prefix "${WEB_DIR}"
            DIST_ROOT="${WEB_DIR}/dist"
            if [[ -d "${DIST_ROOT}" ]]; then
              CANDIDATE=$(find "${DIST_ROOT}" -type d -name browser -print -quit)
              [[ -n "${CANDIDATE}" ]] && DIST_TO_ZIP="${CANDIDATE}" || DIST_TO_ZIP="${DIST_ROOT}"
              OUT_ZIP="${GITHUB_WORKSPACE}/${ARTIFACTS_DIR}/web-core-dist.zip"
              mkdir -p "$(dirname "${OUT_ZIP}")"
              (cd "${DIST_TO_ZIP}" && zip -rq "${OUT_ZIP}" .) || true
            fi
          fi

      # --- NOTE FINALI: usa lo stesso script Python per corpo release ---
      - name: Setup Python
        uses: actions/setup-python@v5
        with: 
          python-version: "3.11"

      - name: Install notes deps
        run: |
          python -m pip install -U pip
          if [ -f tools/release_notes/requirements.txt ]; then
            pip install -r tools/release_notes/requirements.txt
          fi
          python - <<'PY'
          import sys, subprocess
          subprocess.check_call([sys.executable, "-m", "pip", "install", "requests"])
          PY

      - name: Generate final release notes (Markdown)
        id: relnotes
        env:
          ENABLE_LLM: "true"                       # ⇦ ON/OFF qui
          LLM_PROVIDER: "openai"                   # oppure "azure"
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

          # Se Azure:
          # AZURE_OPENAI_API_KEY: ${{ secrets.AZURE_OPENAI_API_KEY }}
          # AZURE_OPENAI_ENDPOINT: ${{ secrets.AZURE_OPENAI_ENDPOINT }}
          # AZURE_OPENAI_DEPLOYMENT: "gpt-4o-mini"

          LLM_MODEL: "gpt-4o-mini"
          LLM_TEMPERATURE: "0.2"
        run: |
          set -euo pipefail
          mkdir -p "${{ env.ARTIFACTS_DIR }}"
          OUT="${{ env.ARTIFACTS_DIR }}/RELEASE_NOTES.md"
          python tools/release_notes/generate_release_notes.py \
            --base "${{ steps.semver.outputs.last_tag }}" \
            --head "${{ steps.semver.outputs.release_branch }}" \
            --version "${{ steps.semver.outputs.tag }}" \
            --out "${OUT}"
          echo "file=${OUT}" >> "$GITHUB_OUTPUT"

      - name: Create tag
        env: { TAG: ${{ steps.semver.outputs.tag }} }
        run: |
          set -euo pipefail
          git tag -a "${TAG}" -m "Release ${TAG}" || true
          git push origin "${TAG}"

      - name: Create GitHub Release (draft)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.semver.outputs.tag }}
          target_commitish: ${{ steps.semver.outputs.release_branch }}
          draft: true
          generate_release_notes: false          # <— disattiva auto-note
          body_path: artifacts/RELEASE_NOTES.md  # <— usa le note generate da Python
          files: |
            artifacts/*.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Append asset links to release notes
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const { owner, repo } = context.repo;
            const tag = ${{ toJSON(steps.semver.outputs.tag) }};
            // poll finché la release è visibile
            let rel = null;
            for (let i = 0; i < 10; i++) {
              try {
                rel = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
                break;
              } catch (e) {
                if (e.status === 404) { await new Promise(r => setTimeout(r, 3000)); continue; }
                throw e;
              }
            }
            if (!rel) { core.warning(`Release ${tag} non ancora visibile: skip.`); return; }
            const assets = await github.rest.repos.listReleaseAssets({ owner, repo, release_id: rel.data.id, per_page: 100 });
            const lines = (assets.data || []).map(a => `- [${a.name}](${a.browser_download_url})`);
            if (!lines.length) return;
            const section = `\n\n### Download\n${lines.join('\n')}\n`;
            await github.rest.repos.updateRelease({ owner, repo, release_id: rel.data.id, body: (rel.data.body || '') + section });

      - name: Upload CI artifacts (for debugging)
        uses: actions/upload-artifact@v4
        with:
          name: release-artifacts-${{ steps.semver.outputs.new_version }}
          path: artifacts
          if-no-files-found: ignore
