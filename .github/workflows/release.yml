name: Release on main

on:
  push:
    branches: [ main ]

permissions:
  contents: write
  issues: write
  pull-requests: write

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  release:
    name: Create Release (branch, tag, draft, artifacts)
    runs-on: ubuntu-latest

    env:
      DOTNET_VERSION: 8.0.x
      NODE_VERSION: 20
      SOLUTION: Momentum.sln
      WEB_DIR: src/web-core
      APPHOST_DIR: src/AppHost
      ARTIFACTS_DIR: artifacts

    steps:
      - name: Checkout (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Calculate next version (SemVer from Conventional Commits)
        id: semver
        shell: bash
        run: |
          set -euo pipefail
          LAST_TAG="$(git describe --tags --abbrev=0 2>/dev/null || true)"
          if [[ -z "${LAST_TAG}" ]]; then LAST_TAG="v0.1.0"; fi
          BASE="${LAST_TAG#v}"

          COMMITS="$(git log --pretty=format:%s "${LAST_TAG}..HEAD" || true)"

          BUMP="patch"
          if echo "${COMMITS}" | grep -Eqi 'BREAKING CHANGE|!:' ; then
            BUMP="major"
          elif echo "${COMMITS}" | grep -Eqi '^feat(\(|:)|^feat!'; then
            BUMP="minor"
          elif echo "${COMMITS}" | grep -Eqi '^fix(\(|:)|^perf(\(|:)|^refactor(\(|:)|^fix!|^perf!|^refactor!' ; then
            BUMP="patch"
          else
            if [[ -n "${COMMITS}" ]]; then BUMP="patch"; fi
          fi

          IFS='.' read -r MA MI PA <<< "${BASE}"
          case "${BUMP}" in
            major) MA=$((MA+1)); MI=0; PA=0;;
            minor) MI=$((MI+1)); PA=0;;
            patch) PA=$((PA+1));;
          esac

          NEW_VERSION="${MA}.${MI}.${PA}"
          echo "new_version=${NEW_VERSION}"           >> "$GITHUB_OUTPUT"
          echo "release_branch=release/v${NEW_VERSION}" >> "$GITHUB_OUTPUT"
          echo "tag=v${NEW_VERSION}"                  >> "$GITHUB_OUTPUT"

      - name: Generate cumulative release notes
        id: relnotes
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const tag = "${{ steps.semver.outputs.tag }}";                 // es. v1.2.3
            const target = "${{ steps.semver.outputs.release_branch }}";   // es. release/v1.2.3

            // 1) prendi l'ultimo tag esistente (escludendo quello che stai creando ora)
            // fallback a v0.1.0 se non ci sono tag
            const exec = require('child_process').execSync;
            let lastTag = "";
            try {
              lastTag = exec('git describe --tags --abbrev=0 2>/dev/null', {encoding: 'utf8'}).trim();
            } catch {
              lastTag = "v0.1.0";
            }

            core.info(`Base tag for notes: ${lastTag} -> ${target}`);

            // 2) confronta commit (base=ultimo tag, head=release branch HEAD)
            const baseRef = lastTag;
            const headRef = target; // compare accetta branch
            const cmp = await github.rest.repos.compareCommits({
              owner, repo, base: baseRef, head: headRef
            });

            // 3) classifica commit per Conventional Commit
            const commits = (cmp.data.commits || []).map(c => c.commit.message.split('\n')[0]);
            const groups = { feat:[], fix:[], perf:[], refactor:[], docs:[], chore:[], ci:[], test:[], style:[], revert:[], other:[] };

            for (const msg of commits) {
              const m = msg.match(/^(\w+)(\([\w\-\./]+\))?:(.*)$/);
              if (m && groups[m[1]]) groups[m[1]].push(msg);
              else groups.other.push(msg);
            }

            function section(title, arr) {
              if (!arr.length) return "";
              return `### ${title}\n` + arr.map(s => `- ${s}`).join("\n") + "\n\n";
            }

            // 4) PR mergiati nel range (opzionale ma utile)
            // cerchiamo PR mergiati tra le due SHAs usando search
            // Nota: per repo privati con tanti PR potresti dover iterare; qui facciamo best-effort
            const mergedSince = cmp.data.base_commit.commit.author.date;
            const mergedUntil = new Date().toISOString();
            const prQuery = `repo:${owner}/${repo} is:pr is:merged merged:${mergedSince}..${mergedUntil}`;
            let prs = [];
            try {
              const res = await github.rest.search.issuesAndPullRequests({ q: prQuery, per_page: 100 });
              prs = res.data.items || [];
            } catch (e) {
              core.warning(`PR search failed: ${e.message}`);
            }

            const prLines = prs.map(p => `- #${p.number} ${p.title}`);

            let body = "";
            body += `## ${tag}\n\n`;
            body += `**Range:** ${lastTag} → ${target}\n\n`;
            body += section("Features", groups.feat);
            body += section("Fixes", groups.fix);
            body += section("Performance", groups.perf);
            body += section("Refactor", groups.refactor);
            body += section("Docs", groups.docs);
            body += section("CI", groups.ci);
            body += section("Tests", groups.test);
            body += section("Chore", groups.chore);
            body += section("Style", groups.style);
            body += section("Revert", groups.revert);
            body += section("Other", groups.other);

            if (prLines.length) {
              body += `### Merged PRs\n` + prLines.join("\n") + "\n";
            }

            core.setOutput('body', body);


      - name: Create / update release branch
        env:
          REL: ${{ steps.semver.outputs.release_branch }}
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git fetch origin --prune
          if git rev-parse --verify "$REL" >/dev/null 2>&1; then
            git switch "$REL"
            git reset --hard origin/main
          else
            git switch -c "$REL"
            git reset --hard origin/main
          fi
          git push --force-with-lease origin "$REL"

      - name: Bump version in solution (best-effort)
        env:
          VERSION: ${{ steps.semver.outputs.new_version }}
        run: |
          set -euo pipefail
          if [[ -f Directory.Build.props ]]; then
            sed -i -E "s|<Version>[^<]+</Version>|<Version>${VERSION}</Version>|" Directory.Build.props || true
          fi
          if [[ -f "${WEB_DIR}/package.json" ]]; then
            jq --arg v "${VERSION}" '.version=$v' "${WEB_DIR}/package.json" > "${WEB_DIR}/package.json.tmp" && mv "${WEB_DIR}/package.json.tmp" "${WEB_DIR}/package.json"
          fi
          if ! git diff --quiet; then
            git add -A
            git commit -m "chore(release): bump version to v${VERSION}"
          fi

      - name: Build artifacts
        run: |
          set -euo pipefail
          mkdir -p "${ARTIFACTS_DIR}"

          # .NET
          dotnet restore "${SOLUTION}"
          dotnet build "${SOLUTION}" -c Release --no-restore

          # AppHost publish + zip solo se c'è output
          if [[ -d "${APPHOST_DIR}" ]]; then
            OUT="${ARTIFACTS_DIR}/apphost-publish"
            dotnet publish "${APPHOST_DIR}" -c Release -o "${OUT}"
            if [[ -d "${OUT}" ]] && compgen -G "${OUT}/*" > /dev/null; then
              (cd "${ARTIFACTS_DIR}" && zip -rq apphost-publish.zip apphost-publish)
            else
              echo "No AppHost publish output to zip."
            fi
          fi

          # web-core
          if [[ -f "${WEB_DIR}/package.json" ]]; then
            npm ci --prefix "${WEB_DIR}"
            npm run build --prefix "${WEB_DIR}"
            if [[ -d "${WEB_DIR}/dist" ]] && compgen -G "${WEB_DIR}/dist/*" > /dev/null; then
              (cd "${WEB_DIR}/dist" && zip -rq "../../${ARTIFACTS_DIR}/web-core-dist.zip" .)
            else
              echo "No web-core dist to zip."
            fi
          fi

      - name: Upload CI artifacts (for debugging)
        uses: actions/upload-artifact@v4
        with:
          name: release-artifacts-${{ steps.semver.outputs.new_version }}
          path: artifacts
          if-no-files-found: ignore

      - name: Create tag
        env:
          TAG: ${{ steps.semver.outputs.tag }}
        run: |
          set -euo pipefail
          # Tagga il commit corrente (release branch appena resettata su origin/main)
          git tag -a "${TAG}" -m "Release ${TAG}" || true
          git push origin "${TAG}"

      - name: Create GitHub Release (draft)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.semver.outputs.tag }}
          target_commitish: ${{ steps.semver.outputs.release_branch }}
          draft: true
          generate_release_notes: true
          files: |
            artifacts/*.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Push release branch updates (version bump commit, if any)
        env:
          REL: ${{ steps.semver.outputs.release_branch }}
        run: |
          set -euo pipefail
          # Se abbiamo fatto un commit di bump versione, pushiamolo
          git push origin "${REL}"
